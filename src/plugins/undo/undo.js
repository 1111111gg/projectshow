/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Jul 21 2023 23:41:07 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */


define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'mic-react-viz/utils',
    'mic-react-viz/constants'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    UTILS,
    CONSTANTS) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of CheckWinCondition.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CheckWinCondition.
     * @constructor
     */
    function undo() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    undo.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
   undo.prototype = Object.create(PluginBase.prototype);
    undo.prototype.constructor = undo;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    undo.prototype.main = function (callback) {
        
            
          
            // Use this to access core, project, result, logger etc from PluginBase.
    const {core, META, logger, activeNode, result} = this;
    let tempHash=[];
    let nodeHash = {};
    const currentPlayerPath = core.getPointerPath(activeNode,'currentPlayer');
    let nextPlayerPath = currentPlayerPath;


    core.loadSubTree(activeNode)
        .then(nodes=>{
                nodeHash = {};
                nodes.forEach(node => {
                    nodeHash[core.getPath(node)] = node;
                });

                let color = core.getAttribute(nodeHash[currentPlayerPath], 'name') === 'PlayerBlack' ?    'black':'white';
                let boardNode = null;
                core.getChildrenPaths(activeNode).forEach(playerOrBoard => {
                    const node = nodeHash[playerOrBoard];
                    if(core.isInstanceOf(node,META.Board)) {
                       boardNode = node;
                       tempHash=UTILS.getPositionHash(core,META, boardNode, nodeHash)
                    }else if(core.isInstanceOf(nodeHash[playerOrBoard], META.Player) && core.getAttribute(nodeHash[playerOrBoard],'color') !== color) {
                        nextPlayerPath = playerOrBoard;
                    }

            });
    

         if(window.preBoard.length>0){

         
        let tempBoard=window.preBoard[window.preBoard.length-1];
      
        

        for (let row = 0; row < 8; row++) {
            for (let column = 0; column < 8; column++) {
                let color = '-';
                
                if (tempBoard[row][column] === 'w') {
                    color = 'white';
                } else if (tempBoard[row][column] === 'b') {
                    color = 'black';
                } else {
                    color = '-';
                }
                
        
                const tempNode = nodeHash[tempHash[row][column]];
        
                
                if (core.isInstanceOf(tempNode, META.Tile)) {
                    const tempChildrenPath = core.getChildrenPaths(tempNode);
        
                   
                    if (tempChildrenPath.length > 0 && core.getAttribute(nodeHash[tempChildrenPath[0]], 'color') !== color) {
                        if (color === '-') {
                            
                            core.deleteNode(nodeHash[tempChildrenPath[0]]);
                        } else {
                          
                            core.setAttribute(nodeHash[tempChildrenPath[0]], 'color', color);
                        }
                    }
                }
            }
        }
        
        window.preBoard.pop()
        console.log(window.preBoard)
    
        return this.invokePlugin('CheckWinCondition',{pluginConfig:{}});
    }
    else{
        callback(error, null);
    }
})

    .then(innerResult => {
       
        console.log(innerResult);

        core.setPointer(activeNode, 'currentPlayer',nodeHash[nextPlayerPath]);
        

        return this.save('undo success');
    })
    .then(() => {
        this.result.setSuccess(true);
        callback(null, result);
    })
    .catch(error => {

        callback(error, null);
    })

}; 

    return undo;
});